셋
배열은 키없이 여러 개의 값을 모아 놓은 것으로 값이 중복되도 상관없음
셋은 키 없이 여러 개의 값을 모아 놓은 것은 배열과 같지만 ,값은 중복되지 않는다

let numSet1 = new Set()
numSet1.add("one")
numSet1.add("two")
    Set(2) {'one', 'two'}
let numSet1 = new Set().add("one").add("two")
    undefined
let numSet2 = new Set([1,2,3])
numSet2
    Set(3) {1, 2, 3}
let numSet3 = new Set([1,2,3,2,1,5])
numSet3
    Set(4) {1, 2, 3, 5}
중복 값이 있는 배열을 받아도 중복값을 모두 제거하고 셋을 만듬

셋의 프로퍼티와 메서드

예 강의실에 출석체크하기 위해 입장하는 학생 이름을 저장할 경우
학생이 잠시 나갔다가 다시 강의실에 들어와도 학생 이름을 2번 저장할 필요가 없으므로 이 경우에는 배열보다 셋이 적함
size 개수를 반환한다 add(값)추가한다 has(값)이 있는 지 체크
delete(값) 삭제 clear()셋 비운다

let students = new Set();
students.add("도래미")
students.add("도다리")
students.add("도미노")
    Set(3) {'도래미', '도다리', '도미노'}
students
    Set(3) {'도래미', '도다리', '도미노'}

students.keys()
    SetIterator {'도래미', '도다리', '도미노'}
; students.values
; ƒ values() { [native code] }
students.values()
    SetIterator {'도래미', '도다리', '도미노'}
students.entries()
    SetIterator {'도래미' => '도래미', '도다리' => '도다리', '도미노' => '도미노'}[[Entries]]0: {"도래미" => "도래미"}1: {"도다리" => "도다리"}key: "도다리"value: "도다리"2: {"도미노" => "도미노"}[[Prototype]]: Set Iterator[[IteratorHasMore]]: true[[IteratorIndex]]: 0[[IteratorKind]]: "entries"
[값,값] 형식으로 모든 값을 반환한다entries()

이터러블 객체
이터러블 객체에서 이터러블(iterable)이란 순서대로 처리할 수 있다
예를 들어 배열은 인덱스와 값을 가지고 있으므로 인덱스 0부터 값을가져와서 처리할수 있기 떄문에 이터러블 객체인다
문자열과 배열, 맵, 셋이 이터러블 객체이다
이터러블 객체에서는 다음과 같은 기능을 사용할 수 있따
for...of반복문
전개연산자(...)
구조 분해 할당

let hi = "hello"
for(let ch of hi){
console.log(ch)
}
VM3925:3 h
VM3925:3 e
2VM3925:3 l
VM3925:3 o
undefined
//전개 연산자 사용
let chArray = [..hi]
chArray

//전개 연산자 사용
let chArray = [...hi]
chArray
(5) ['h', 'e', 'l', 'l', 'o']
//구조 분해 할당 사용
let [ch1,ch2] = hi
ch1
'h'
ch2
'e'
ch3

iterator 객체
콜솔 창에서 배열을 만든 후 배열의 프로퍼티 메서드를 확인해 본다
이터러블 객체에는 Symbol.iterator 메서드가 포함되어 있다 -> 이터러블 프로토콜이라 부름
Symbol.iterator 메서드를 실행하면 iterator 객체가 반환된다

let arr = [1, 2, 3, 4, 5]
let it = arr[Symbol.iterator]()
undefined
이터레이터 객체란 객체의 요소를 순서대로 꺼낼 수 있는 객체
next() 메서드가 있어 가능함
next() 메서드는 value와 done 반환 value는 반환 값 done-이터레이터 객체가 끝났는지 여부

let arr = [1, 2, 3, 4, 5]
let it = arr[Symbol.iterator]()
it.next()
{value: 1, done: false}
it.next()
{value: 2, done: false}
it.next()
{value: 3, done: false}
it.next()
{value: 4, done: false}
it.next()
{value: 5, done: false}
it.next()
{value: undefined, done: true}

일반 객체는 이터러블 하지 않는다
객체 안에 많은 자료를 저장하고 처리해야하기 떄문에 전개 연산자나 구조 분해 할당을 사용하거나 for...of문으로 순회하는것이 편리
일반객체를 이터러블하게 만들어서 사용(제너레이터 함수 사용)

이터러블 객체는 Symbol.iterator 메서드가 포함된다는것은 해당 객체가 for...of 루프를 사용하여 순회 가능하다는 의미
이터레이터 객체는 next() 메서드를 가지고 있어 for...of 루프에서 반복적 호출
Symbol.iterator 메서드가 없으면 for..of 루프를 사용해 객체를 순회 할 수 없다

이터러블 객체는 Symbol.iterator 메서드가 포함된다는것은 해당 객체가 for...of 루프를 사용하여 순회 가능하다는 의미
이터레이터 객체는 next() 메서드를 가지고 있어 for...of 루프에서 반복적 호출
Symbol.iterator 메서드가 없으면 for..of 루프를 사용해 객체를 순회 할 수 없다
Symbol은 유일한 값을 나타내기 위한 자바스크립트 데이터 탑중 하나
Symbol은 객체의 프로퍼티를 식별하는데 사용
예 map이나 set 같은 자료구조에서키로 symbol 값을 사용하여 다른 키와 혼동되지 않고 고유한 값을 가지게 할수 있습니다
symbol은 내부적으로 사용되는 프로퍼티 표시하기 위해 사용 -> Symbol.iterator는 이터레이터 반환하는 데 내부적으로 사용되는 프로퍼티 ㅇ비니다
Symbol은 자바 스크립트에서 유일한 값이 필요한 상황에서 유용하게 사용

제너레이터 함수
일반 객체를 이터러블하게 만들기 위해 사용하는 함수
일반 함수와 구별하기 위해function 다음에 기호를 붙여서 작성하고 함수 안에 return문 대신 yield문 사용

let arr = [1, 2, 3, 4, 5]
let it = arr[Symbol.iterator]()
it.next()
    {value: 1, done: false}
it.next() 호출하여 배열의 첫번재 항목 반환

symbol.iterator를 사용하는 이유는 for...of 루프와 같은 일부 자바스크립트 기능이 이터러블 객체를 요ㄱ구하기 떄문
이터러블 객체는 Symbol.iterator메서드를 구현해야하면 해당 메서드는 이터레이터 객체를 반환해야함
따라서 이터레이터 사용하여 객체를 순회하려면 이터레이터 객체를 생성해야합니다

Symbol.iterator를 사용하면 자바스크립트 엔진에서 내부적으로 for...of 루프뢍 같은 기능을 최적화 할수 있음

unction* gen(){
    yield 1;
    yield 2; 
    yield 3;
}
    undefined
제너레이터 함수는 function*키워드를 정의하면 함수 내부에서 yield키워드를 사용하여 값을 반환

제너레이터 함수는 function*키워드를 정의하면 함수 내부에서 yield키워드를 사용하여 값을 반환합니다 
yield키워드는 해당 값을 반환하고 함수의 실행을 일시 중지함
그리고 다음 호출시 해당 위치부터 다시 시작해 이전에 중지된 지점까지 실행 제개

let g1 = gen()
g1.next()
    {value: 1, done: false}
g1
    gen {<suspended>}
next()메서드를 호출할 떄마다 , yield키워드에서 중지된 지점부터 다시 실행되며 반환할 값이 없을 떄 done 값이 true
제너레이터함수는 비동기 처리나 이터레이터 같은 다양한 용도로 사용될수 있으며 함수형 프로그래밍에서 중요한 개념으로 사용

http
클라이언트와 서버 간에 자료를 주고받으려면 미리 약속된 규칙이 필요하다
이것을 프로토콜 protocol 이라고 한다 웹에서는 http hyperText Transfer Protocol라는 프로토콜 사용
클라이언트에서 서버로 자료 요청하는 것은 http 요청 http request
서버에서 응답해서 클라이언트로 자료를 보내는것은 http 응답 http response라고 함
웹 브라우저에서 구글 검색 사이트를 찾아 가려면 http:/www.google.com 입력
최근 크롬 웹 브라우저에서는 보안을 위해 https 프로토콜을 사용할 것을 권장
아직 http 를사용하는사이트는 주의요함 이라는 메시지가 표시됨
클ㄹ라이이언트에서 사이트 주소를 입력하고 [enter]를 누를떄
사이트 주소 뿐 아니라 사용 중인 시스템 정보와 웹 브라우저 정보 사용한 언어 등 다른 정보까지 함께 전송된다-> 서버로 요청할 떄보내는 헤더를
요청헤더라 한다
서버에서 입력한 사이트를 찾아 클라이언트로 보낼떄 
응답 메시지를 보내는 시간 메시지를 클라이언트에 어떻게 표시할 지 등의 정보는 응답 헤더에 담기고 
이미지나 텍스트 값은 실제 사이트 내용응ㄴ 응밥 본문 reponse body에 담겨 전달
크롬에서 네트워크 확인

웹 브라우저에서 구글 사이트로 접속해 웹 개발자 도구 창을 열로 네트워크 탭 클릭
f5를 누르거나 새로고침 아이콘을 클릭해 현재 사이트를 불러온다
클라이언트에서 구글 사이트를 보여 달라고 했기 때문에 구글 사이트에서 사용한 텍스트와 아이콘 이미지 등 요소들을 서버에서 다운로드

헤더는 전체적인 네크워크 상태를 요약한것
응답헤더는 서버에서 구글 사이트 정보를 보내면서 함께 보내온것
요청헤더는 웹 브라우저에 구글 사이트 주소를 입력해 서버로 보낼때 즉 http요청할떄 함꼐 넘겨진 정보
[응답]탭을 클릭하면 서버에서 클라이언트로 응답 헤더와 함께 넘어온 실제 내용이 나타남
우리가 알고 있는 html 문서형태인데 이 내용ㅇ이 웹 브라우저에 표시된다
웹 브라우저의 네트워크 창에는ㄴ get post 같은 요청 방식이 함꼐 표시된다
get 방식

서버에 자료를 요청할 떄사이트 주소 뒤에 자룔를 붙여서 보내는 방식

get을 사용하면 웹 브라우저의 주소 표시줄에 요청 메시지가 함꼐 표시되고 따로 요청 본문은 사용하지 않는다
서버로 사이트 주소를 보내면서 요청 자료도 함꼐 공개되기 때문에
이렇게 요청 자료가 무엇인지 공개되더라도 문제가 없을 경우 사용하는 방식
예 구글 사이트에서 자바스크립트 검색하면 웹 브라우저 서버로 보내는 ㅂ요청 헤더에 get 메서드 사용

post 방식
post를 사용하면 요청 내용일 겉으로 드러나지 않고 요청 본문 Request body 따라 담아서 보낸다
예 로그인 창에 아이드와 비밀번호를 입력한 후 로그인 버튼을 클릭하면
사용자가 입력한 아이디나 비밀번호는 ㄴ 네트워크 외부에서 알아볼 수 없도록 요청 본문에 담아서 서버로 넘겨진다

응답상태
클라이언트의 요청을 받은 서버가 필요한 작업을 처리하고 그 결과를 클라이언트로 보낼떄 
서버로 요청한 것이 성공적으로 처리되었는지 또는 요청한 파일이 없어서 실패햄ㅆ는지 등을 응답 상태를 상태 칼럼에 숫자 표시
서버에서 자료를 받아 프로그래밍할 떄는 응답 상태를 확인한 후 진행

자료 요청을 수락했거나 자료 전송이 성공적으로 끝남 200

4xx 클라이언트 주소를 잘못 입력했거나 요청이 잘못되었다
404 문서를 찾을수 없다
400 요청 실패함
5xx 서버측 오류 처리할 수 없음
500 서버 내부에 오류 발생
503 요청한 서비스 이용 불가

데이터 교환 방식
서버와 클라이언트 간에 자료를 주고 받기위해 이해할수 있는 형식을 사용해야헌더
xml은 컴퓨터에서 처리하는 모든 문서의 표준 형식이기 떄문에 웹에서 사용 가느ㅜㅇ
최근에는 json이라는 형식을 많이 사용되는

json 특징
텍스트롬나 구성 되었ㅋ끼 떄문에 서버와 클라이언트 사이에 주고 받을때 전송속도가 아주 빠름
json 프로그래밍 언어나 플렛폼에 대헤 독립적이기 떄문에 c++이나 자바 자바 스크립트 파이썬
등 많은 언어에서 사용
자바스크립트 사용자라면 누구나 알고 임쓴 표기법 사용하기 떄문에 읽기 쉬움
필요에 따라 자바스크립트 객체로 변환하기도 쉬움

{
    "이름" : 값,
}
중괄호 사이에 이름과 값으로 구성
json 에 서 이름 부분에 ㅂ나드시 큰따옴표를 붙이는것이 큰차이점

반드시 큰따옴표롤 묶어야 됨

json이름에 ㄴ공백 언더바 하이푼 사용 가능하다는
문법적으로 다음 형식 가능하다는{ "full name" : "도다리"}
문법적으로 다음 형식 가능하다는{ "full-name" : "도다리"}
    하지만 이름에 공백이 나하이픈이 있을 경우 프로그램을 통해
    그 이름에 접근할 떄 쉽지않기 떄문에 둘 이상의 단어로 된 이름을 사용한다면
    언더스코어_사용하는 것이 좋다
    {"full_name" : "도다리"}

    json 값
    객체에서는 값 부분에 함수(메서드)도 사용가능하지만
    json의 값에는 숫자 문자열 boolean null 배열만 사용가능 함수는 사용 불가

    json 구조
    이름과 값의 쌍으로 이루어짐
    데이터는 쉼표로 나열됨
    객체는 중괄호({})둘러쌓임
    배열([])둘러쌓임

    json데이터 
    json데이터는 이름과 값의 쌍으로 구성되는 데이터 이름, 콜론(:)으로 구성됨
    "데이터이름" : "값",            ex)"name" : "식빵"

    데이터의 값으로 아래 6가지 올수 있따
    숫자, 문자열, 불리언, 객체, 배열, null

    숫자형 : json 에서는 정수와 실수 모두 사용할 수 있지만 8진수나 16진수를 사용한
    표기법은 지원하지 않는다
    문자열: json 문자열은 항상 큰따옴표("")로 묶어야 한다
    논리값과 null:true/false 값을 가지는 논리형을 사용할 수도 있고 null 유형도 사용가능
    문자열, 배열 : 문자열이나 배열으 ㄹ값으로 사용 가능하다
    json 문자열 안에 또다른 json 문자열을 넣을수 있다
    json에서 배열을 사용할 떄에도 일반 배열과 마찬가지로 대괄호([])사용

    json 문자열
    json 문자열 안에 또 다른 json 문자열 지정 가능하다


    객체를 json 형식으로 변환하기
    클라이언트에서 정보를 처리할떄는 객체 사용
    객체를 json형식으로 저장하거나 json 형시그올 요구하는 서버로 넘기려면
    ->객체를 json 형식으로 변환해야함 직렬화 라고 한다
    json.stringify(객체)

    let student = {name:"도다리", major:"컴퓨터 공학", grade :2}
    let json = JSON.stringify(student)

    json을객체로 변환
    서버에서 가져온 json 자료를 사용하려면 객체 형태롤 변환해야 한다
    -> 이것을 파싱(parsing)이라함
    JSON.parse(JSON문자열)


    function displayLetter() {
    console.log('A');
    setTimeout( () => {
        console.log('B');
        setTimeout( () => {
            console.log('C');
            setTimeout( () => {
                console.log('D');
                setTimeout( () =>{
                    console.log("stop");
                },1000);
                },1000);
            },1000);
        },1000);
    }
displayLetter();
                
VM742:2 A
undefined
VM742:4 B
VM742:6 C
VM742:8 D
VM742:10 stop
콜백이 계속 반복되는 상태를 콜백지옥이라고 한다
소스의 가독성이 떨어지고 오류가 발생했을때 디버깅하기 어렵다
예를 들어 1초마다 A -> B -> C -> D -> stop 순으로 표시
